# Hack 汇编编译器实现

## 软件架构

- 语法分析器（parser.py）：对输入文件进行语法分析；
- 编码（code.py）：提供所有汇编命令所对应的二进制代码；
- 符号表（symbol_table.py）：处理符号；
- 主程序（main.py）：驱动整个编译过程。

### Parser模块

- 主要功能：将汇编命令分解为其所表达的内在含义（域和符号）。

### Code模块

- 主要功能：翻译每个域到它相应的二进制值。

### SymbolTable模块

- 主要功能：管理符号（symbol）表。

### Main模块

- 主要功能：初始化I/O文件，驱动程序。

## 整体逻辑

1. 初始化
   - Parser
   - Symbol Table
2. 第一遍
   - 读取所有的命令，仅注意标签（label）并且更新symbol表
3. 重新读取和翻译命令
4. 主循环
   - 获得下一条汇编语言命令并分析；
   - 对于A命令：翻译symbols为二进制地址；
   - 对于C命令：获得每个部分的代码并将他们放到一起；
   - 输出作为结果的机器语言命令。

## 功能清单

- 开发一个基础的汇编编译器：翻译无符号汇编程序；

  对于Add.asm：

  读取和解析命令：

  - [x] 读取一个给定名字的文件中的命令；
  - [x] 能够过滤掉注释行并读取第一条命令；
  - [x] 能够移动到下一条命令；
  - [x] 能够区分当前命令的类别为A还是C。

  将助记符转化为代码：

  - [x] 将A（无符号）命令转化为对应的十进制值
  - [x] 如果是C命令，能正确识别各个域
  - [x] 能够正确翻译C命令的相关域的二进制代码
  - [x] 将翻译后的二进制代码整合到一个列表中。
  - [x] 能够将当前翻译后的二进制代码保存到同名的.dst文件

  对于MaxL.asm：

  - [x] 完善C指令各个编码的映射

- 开发一个能够处理符号的汇编编译器；

  处理符号
  
  - [x] 能够创建空的SymbolTabel类，里面自带初始的16个保留符号，主要的数据是一个映射字典，自带addEntry、contains和get_address方法
  - [x] 第一遍：构建符号表但不生成代码
  - [x] max.asm
